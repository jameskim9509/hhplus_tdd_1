# 요구사항
- PATCH  `/point/{id}/charge` : 포인트를 충전한다.
- PATCH `/point/{id}/use` : 포인트를 사용한다.
- GET `/point/{id}` : 포인트를 조회한다.
- GET `/point/{id}/histories` : 포인트 내역을 조회한다
- 잔고가 부족할 경우, 포인트 사용은 실패하여야 합니다.
- 동시에 여러 건의 포인트 충전, 이용 요청이 들어올 경우 순차적으로 처리되어야 합니다.

# 요구사항 분석
1. 포인트 충전, 사용, 조회, 내역 조회에 대한 기본 기능 구현
2. 실패 케이스 분석
- 포인트 사용
  잔고 부족시 포인트 사용 실패
- 포인트 충전
  10만 포인트 이상 충전 시 포인트 충전 실패 (최대 잔고 10만 포인트)
3. 추가 요구사항 고려
- 각 유저별 포인트 사용/충전/조회는 동시에 실행 가능
- 동일한 유저에 대한 포인트 사용/충전/조회는 순차적으로 처리되어야 한다.

추가 고민 사항
1. '순차적'의 기준
- 사용자 기준 보낸 요청 순으로 처리하게 되면 포인트 서비스는 일정기간 대기해야하므로 성능저하가 발생할 수 있다.
- 보낸 요청이 컨트롤러에 도착하는 순으로 처리하게 되면 서비z를 바로 처리할 수 있다.

2. 포인트 내역 저장 기준
- 실패 내역을 저장함으로써 누군가에 의해 악용(최대 잔고를 초과한 반복적인 충전으로 ROW 낭비 등)될 수 있는 상황을 고려해 실패는 저장하지 않는다.

3. 포인트 내역 조회 기준
- 포인트 내역 테이블의 컬럼이 많지 않고, 민감한 정보를 포함하지 않으므로 조회시 모든 컬럼에 대한 ROW를 반환한다.

# 동시성 제어 방법

## 1. volatile 키워드 사용하기
### 등장 배경
멀티 스레딩을 수행할 때, 각 스레드가 할당된 서로 다른 CPU가 서로 다른 캐시를 사용한다.
이때, 메인 메모리와 캐시가 늦게 동기화 되면 다른 스레드는 최신의 값을 read하지 못하여 동시성이 보장되지 않는다.
이를 해결하기 위해서 volatile이라는 키워드가 등장하였다.
### 동작 원리
volatile 키워드를 사용하면 volatile 키워드에 해당하는 변수가 연산을 수행함과 동시에 메인메모리에 동기화되는 것을 보장한다.
### 장점
멀티 스레딩 환경에서 항상 최신의 값을 가져옴을 보장할 수 있다.
### 단점
한 스레드가 write 하기 전에 다른 스레드가 read & write 하면 전 스레드의 write 한 값이 반영되지 않아 동시성을 보장하지 못한다.

## 2. synchronized 키워드 사용하기
### 등장 배경
volatile의 단점을 해결하는 대안으로 등장하였다.
### 동작 원리
synchronized 키워드를 사용하여 메소드나 일부 코드를 synchronized 블록으로 지정하면 한번에 한 스레드만 해당 블록을 사용할 수 있도록 강제하여 동기화를 보장한다.
### 장점
완전히 thread-safe한 코드를 작성할 수 있다.
### 단점
스레드가 블록을 사용 중일 때 다른 스레드는 해당 블록을 대기해야 하므로, 스레드의 개수가 많아질수록 synchronized 블록은 병목점이 되어 성능 저하가 발생할 수 있다.

## 3. atomic 클래스 사용하기
### 등장 배경
synchronized의 성능저하 문제와 volatile의 완전한 동시성을 보장하지 못하는 문제점을 해결하기 위해 등장하였다.
### 동작 원리
volatile이 동작하는 방식과 같이 non-blocking 방식을 사용하지만, CAS(Compare And Set)알고리즘을 사용하여 연산을 수행한 대상이 메인 메모리의 값과 일치하는지 비교 후에 일치한 경우에만 값을 갱신하여 동시성을 보장한다.
### 장점
synchronized의 방식에 비해 성능이 좋고, locking을 사용하지 않아 교착상태를 신경쓰지 않아도 된다.
### 문제점
충돌이 잦은 멀티 스레드 환경에서 재시도를 반복적으로 수행할 경우 성능이 급격히 저하될 수 있고, CAS가 단일 변수의 원자적 연산에 최적화된 방식이다 보니 복잡한 연산을 수행할 때 설계와 구현이 어렵다.